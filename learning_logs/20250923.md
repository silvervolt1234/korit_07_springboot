# SpringBoot 복습
Entity의 개념

JPA가 Entity와 어떻게 연결되고 inmememory database인 h2와 어떻게 연결이 되어있는가

Entity 클래스의 경우 DB에서의 테이블 역할. Entity 클래스들의 field들은 column 역할. JPA와 연동되서 필수적으로 기본 생성자 요구. ID 값을 AUTO로 설정해서(=생성될때마다 DB에서 고유 ID값 부여) @AllArgsConstructor 적용시 오류

1. Lombok을 적용하지 않은 경우
```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.NoArgsConstructor;

@Entity
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    private String firstName, lastName;

    // Lombok을 사용하지 않고 기본 생성자 및 ownerId를 제외한 RequiredArgsConstructor를 생성
    // Lombok을 사용하지 않고 각 field에 대한 getter setter 생성

    public Owner() {
    }

    public Owner(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public Long getOwnerId() {
        return ownerId;
    }

    public void setOwnerId(Long ownerId) {
        this.ownerId = ownerId;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}
```

2. Lombok 적용
```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.*;

@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    @NonNull
    private final String firstName;
    @NonNull
    private final String lastName;
}
```
`@NoArgsConstructor(force = true)` : final 필드가 있는 경우에도 해당 필드를 null로 초기화하는 생성자를 강제로 생성해서 `final` 키워드가 가붙은 경우도 JPA에서 요구되는 기본 생성자를 만들 수 있고 `@RequiredArgsConstructor`과 충돌 X

## 테이블 간의 관계 추가
car 테이블과 일대다(1:N) 관계에 있는 owner라는 새 테이블 생성. 일대 다 관계는 소유자가 한 명이 여러대의 자동차를 가질 수 있지만 한 자동차의 소유자는 1명

domain 패키지에는 Owner라는 엔티티 클래스와 OwnerRepository라는 repository 인터페이스를 만들고 OwnerRepository JpaRepository를 상속 받아야 함

이상의 일대다 관계를 추가하려면 `@ManyToOne`과 `@OneToMany` 애너테이션(jakarta.persistence)을 이용. 외래 키를 포함한 Car 엔티티 클래스에서는 `@ManyToOne`을 사용. 그리고 외래키를 추가해서 field 구성 변화

DB적으로 보면 car table에 외래키인 ownerId를 추가하는 개념. 그렇기에 Car entity class에는 Owner 관련 field를 추가해야 하고 getter / setter 역시 요구. 모든 JOIN 관계는 FetchType.LAZY를 사용. 대다(toMany) 관계는 기본값이여서 FetchType을 정의할 필요가 없지만 대일(toOne) 관계는 반드시 명시

FetchType : DB에서 데이터를 검색하는 전략을 정의
- EAGER : 즉시 검색
- LAZY : 지연 검색

얘제에서 지연검색(LAZY)는 DB에서 소유자를 검색하면 해당 소유자와 연관된 모든 자동차를 검색. 즉시검색(EAGER)은 해당 소유자의 모든 자동차를 즉시 검색

```java
// Car.java
package com.example.cardatabase.domain;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@Data
@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String brand, model, color, registrationNumber;
    private int modelYear, price;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner")
    private Owner owner;

    public Owner getOwner() {
        return owner;
    }

    public void setOwner(Owner owner) {
        this.owner = owner;
    }

    public Car(String brand, String model, String color, String registrationNumber, int modelYear, int price) {
        this.brand = brand;
        this.model = model;
        this.color = color;
        this.registrationNumber = registrationNumber;
        this.modelYear = modelYear;
        this.price = price;
    }
}


// Owner.java
package com.example.cardatabase.domain;

import jakarta.persistence.*;
        import lombok.*;

        import java.util.List;

@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    @NonNull
    private final String firstName;
    @NonNull
    private final String lastName;

    // 소유자는 다수의 차들을 가질 수 있어서 Collections 사용
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "owner")
    private List<Car> cars;
}
```
이상의 코드에서 `@Data`를 달아둔 경우 겹치지만 Owner과 관련된 getter / setter를 코드로 작성한 반면 `@Getter, @Setter`를 명시한 Owner 클래스는 cars 관련 getter / setter를 작성하지 않음

Owner 클래스의 `@OneToMany` 애너테이션에는 특성 존재
1. cascade 속성은 삭제 / 업데이트 시 연속 효과 적용
- ALL로 설정시 모든 작업 연속 적용
- Owner를 삭제시 그 소유자와 연결된 Car 객체들도 전부 삭제
2. mappedBy="owner" 속성 설정 : Car 클래스 사이에 이 관계의 외래 키인 owner 필드가 존재함을 명시

어색하게 느껴질만한건 ownerId 필드 하나만 가지고 와서 연결짓는게 아니라 Owner 클래스를 통쨰로 들고와서 Car에 field로 삼는다는 점

## H2 -> MariaDB로 이식
