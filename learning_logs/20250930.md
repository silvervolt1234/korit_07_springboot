# Spring Security 추가 정리
## 정의 
- Spring 기반의 애플리케이션 보안(Authentication / Authorization)을 위한 표준 프레임워크. 서블릿 필터(Servlet Filter) 체인을 기반으로 동작하고 웹 요청에 대한 보안을 체계적 처리. 단순 로그인 기능 외에 CSRF 공격 방지, 세션 관리, 권한 기반 접근 제어 등 포괄 기능 제공

## 특징
1. 포괄적 보안 기능 : 인증(Authentication) / 인가(Authorization) 뿐 아니라 일반적 웹 보안 위협에서 애플리케이션을 보호
2. 유연한 설정 : Java 기반의 설정을 통해 유연하게 보안 정책을 설정 가능
3. 서플릿 필터 기반 : 요청이 컨트롤러에 도달하기 전 여러 보안 필터를 거치게 해 선제적 보안 검사 수행
4. SpringBoot와의 통합 : `spring-boot-starter-security` 의존성만 추가하면 기본적인 보안 기능이 자동 설정되 빠르게 적용 가능

## SecurityConfig
- Spring Security의 보안 구성(Config)을 담당하는 Java 클래스로 해당 클래스에는 `@Configuration`, `EnableWebSecurity` 애너테이션 추가로 Spring Security의 웹 오안 설정을 활성화하고 커스터마이징 가능
- 과거에는 `WebSecurityConfigurerAdapter`를 상속받아 configure() 메서드를 오버라이딩 하는 방식으로 사용했지만 SpringBoot 3.x 버전부터는 SecurityFilterChain 빈(bean)을 등록하는 방식 권장. 현재의 방식은 컴포넌트 기반의 구성으로 모듈화되고 유연한 보안 구성 가능

### SecurityConfig의 핵심 역할
1. HTTP 요청에 대한 접근 제어 : 특정 URL 패턴에 대해 인증된 사용자만 접근을 허용하거나 특정 권한(Role)을 가진 사용자만 접근 가능하게 설정 가능
2. 인증 방식 설정 : 폼 로그인(Form Login), HTTP Basic 인증, OAuth2 로그인 등 다양한 인증 방식 설정하고 커스터마이징 가능
3. 로그아웃 처리 : 로그아웃 URL 및 로그아웃 성공 후 처리 로직 정의
4. 비밀번호 암호화 `PasswordEncoder`를 빈으로 등록해 사용자의 비밀번호를 암호화하고 검증
5. CSRF, CORS 설정 : CSRF 보호 기능을 활성화하거나 비활성화하고 CORS 정책 구성

### SecurityConfig 코드 예시

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    // 비밀번호 등록을 위한 PasswordEncoder 빈 등록
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    // Spring Security의 filterChain 작성
     @Bean
    public SecurityFillterChain securityFillterChain(HttpSecurity http) throws Exception {
        http
            // 1. 인가(Authorization)
                .authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/users/**").authenticated()   // /users/**는 인증된 user만 가능\
                .requestMatchers("/manager/**").hasAnyRole("ADMIN", "MANAGER")  // /manager/** 경로는 role이 ADMIN이거나 MANAGER인 user만 가능
                .requestMatchers("/admin/**").hasRole("ADMIN")  // /admin/**는 role이 ADMIN인 user만 가능
                .anyRequest().permitAll() // 나머지 경로에 대한 요청들 접근 허용
                )
            // 2. 폼 로그인(Form Login) 구성
                .formLogin(form -> form
                        .loginPage("/login")    // 커스텀 로그인 페이지의 URL 지정
                        .loginProcessingUrl("/loginProc") // 로그인 처리 URL
                        .defaultSucessUrl("/")      // 로그인 성공 시 이동할 default URL
                        .permitAll()            // 로그인 페이지는 모든 사용자가 접근 가능
                )
            // 3. 로그아웃 설정
                .logout(logout -> logout
                        .logoutUrl("/logout")   // 로그아웃 처리 URL
                        .logoutSuccessUrl("/")  // 로그아웃 성공시 이동 URL
                        .invalidateHttpSession(true)    // 세션 무효화
                        .deleteCookies("JSESSIONID")     // 쿠키 삭제
                )
            // 4. CSRF 보호 비활성화(API 서버의 경우)
                .csrf(csrf -> csrf.disable());
     }
}
```
- 이상의 코드 상세 설명
  1. authorizeHttpRequests : HTTP 요청에 대한 인가 규칙 구성
    - requestMatchers() : 특정 URL 패턴을 지정
    - authenticated() : 인증된 사용자만 접근 허용
    - hasAnyRole(), hasRole() : 특정 역할을 가진 사용자만 접근을 허용. Spring Security에서 역할(Role)은 기본적으로 "ROLE_" 접두사가 붙어서 처리
    - permitAll() : 모든 사용자의 접근 허용
    - anyRequest() : 위에서 설정한 규칙 외의 모든 요청. 그래서 인가 규칙은 구체적 경로를 먼저 구성하고 포괄 경로는 나중에 구성
  2. formLogin : 폼 기반 로그인 설정
    - loginPage() : 기본 제공되는 로그인 페이지 대신 사용할 커스텀 로그인 페이지의 경로 지정
    - loginProcessingUrl() : 로그인 폼 데이터 처리할 URL 지정. 이 URL에 대한 POST 요청을 Spring Security가 가로채서 인증 처리
    - defaultSuccessUrl() : 로그인 성공 후 사용자를 리다이렉션할 기본 페이지 지정
  3. logout : 로그아웃 관련 설정
    - logoutUrl(): 로그아웃 처리할 URL 지정
    - logoutSuccessUrl() : 로그아웃 성공 후 리다이렉션될 페이지 지정
    - invalidateHttpSession(true) : 로그아웃 시 HTTP 세션 무효화
    - deleteCookies("JSESSIONID") : 로그아웃시 지정 쿠키 삭제
  4. csrf(csrf -> csrf.disable()) :CSRF 보호 기능을 비활성화. 세션 기반 인즈잉 아닌 JWT와 같은 토큰 기반 인증을 사용하는 API 서버의 경우 일반적으로 비활성화

Java 관련 visual studio code Extension

- Code Runner -> Java 프로젝트 실행 용
- Debugger for Java
- Extension Pack for Java

AppUser / AppUserRepository를 생성해 DB에 AppUser 관련 테이블이 생겼고 Spring Security 의존성 도입으로 default login 가능

이제 보안 로직을 현 MVC 패턴에 맞게 설정

1. 사용자 인증을 위한 Service 계층 구현 : Spring Security가 데이터베이스의 사용자 정보를 기반으로 인증을 수행하게 UserDetailsService 구현
  - service 패키지 내에 UserDetailsServiceImpl 클래스를 생성하고 UserDetailsService 구현
```java
package com.example.cardatabase4.service;

import com.example.cardatabase4.domain.AppUser;
import com.example.cardatabase4.domain.AppUserRepository;
import org.springframework.security.core.userdetails.User.UserBuilder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import java.util.Optional;

import static org.springframework.security.core.userdetails.User.withUsername;

public class UserDetailsServiceImpl implements UserDetailsService {
    private final AppUserRepository appUserRepository;

    public UserDetailsServiceImpl(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<AppUser> user = appUserRepository.findByUsername(username);

        UserBuilder builder = null;
        if(user.isPresent()) {
            AppUser currentUser = user.get();       // user 자체는 Optional이고 AppUser가 아니다
            builder = withUsername(username);
            builder.password(currentUser.getPassword()).roles(currentUser.getRole());
        } else {
            throw new UsernameNotFoundException("User Not Found.");
        }

        return builder.build();
    }
}
```
위 코드는 cardatabase_2의 UserDetailsServiceImpl과 코드라인이 일부 변경. 그 과정에서 AppUserRepository 내부에 findByUsername(String username) 추상 메서드를 정의했는데 일반적인 방법으로 한게 아닌 오류 발생 후 intelij 내부 기능으로 자동 생성

또한 User 클래스를 가진게 아닌 static 메서드를 import 하는 방식으로 코드라인 감소

builder를 가지고 외사 chaining method를 도입해 builder 객체 생성


2. JWT 토큰 생성 및 검증 Service 구현 : 로그인 성공 시에 JWT 토큰을 발급하고 이후의 모든 요청에서 토큰을 검증하는 JwtService를 생성
   - 관련 의존성을 추가하고 service 패키지에 JwtService 생성

3. 로그인 Controller 및 관련 클래스 생성 : 로그인 요청 시 ID와 비밀번호 저장. 그러나 무조건 AppUser Entity가 아니고 새로 생성 했었음
   - domain 패키지 내에 AccountCredentials라는 Record 생성
   - web 패키지에 LoginController 생성

4. JWT 인증 필터 및 예외 처리 구현 : `/login`을 제외한 모든 API 요청을 가로채서 JWT 토큰의 유효성을 검사하는 Filter
   - 루트 프로젝트 패키지에 AuthenticationFilter 생성
   - 
5. AuthEntryPoint(인증 실패 처리) : 로그인 실패시 현재대로면 403이 떠야 하는데 이 부분을 401 처리로 변환
   - 루트 프로젝트 패키지에 AuthEntryPoint 생성

6. 이상까지의 상황을 반영한 SecurityConfig 작성
   - 루트 패키지에 SecurityConfig 생성

7. 현재 AppUser를 객체추가하려면 SQL문을 통하거나 CommandLineRunner를 통해야하기에 생성된 AppUser 객체를 가지고 로그인 성공 시 / 실패 시를 확인하면 spring-data-rest 없는 상태 부분 구현