# RESTful API 문서화
- RESTful API는 이를 이용하는 개발자가 그 기능과 작동을 이해할 수 있게 적절히 문서화
- Open API 3를 이용해 이용 가능한 엔드포인트 목록 / 허용 데이터 양식 / API와 상호작용하는 방법 등을 포함

OpenAPI3를 이용한 자동 문서 생성 방식(Swagger 명세)인데 이는 RESTful API를 위한 API 설명 명세서에 해당. RAML도 있으나 한국에서는 잘 사용 안됨

OpenAPI 역시 라이브러리

1. SpringDoc OpenAPI Starter WebMVC UI 사용

`implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2`

상기해야할 점은 외부 라이브러리를 사용하면 Java 자체를 이용하는게 아니여서 의존성 추가가 선행되어야 함. 의존성 추가는 build.gradle에서 진행

2. com.example.cardatabase 패키지에 OpenApiConfig 클래스 생성
```java
package com.example.cardatabase;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI carDatabaseOpenApi() {
        return new OpenAPI()
                .info(new Info()
                        .title("Car REST API")
                        .description("My car Stock")
                        .version("1.0")
                );
    }
}
```
이상의 코드에서 `@Bean`이라는 애너테이션이 존재하고 return new OpenApi.info(); 라는 지점에서 chaining method 개념을 도입했고 거기 new Info() 내에서 객체 생성을 빌더 패턴으로 한 사실에 주목

3. application.properties 수정
```properties
spring.application.name=cardatabase
spring.datasource.url=jdbc:mariadb://localhost:3310/cardb
spring.datasource.username=root
spring.datasource.password=1234
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create-drop
spring.data.rest.basePath=/api
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/api-docs
```

이후 http://localhost:8080/swagger-ui/index.html

# Bean / @Bean
- Spring에서 Bean은 스프링 IoC(Inversion of Control : 제어의 역전) 컨테이너가 관리하는 Java 객체

## Bean의 정의
Spring이 등장 전에는 개발자가 직접 new 키워드를 통한 객체 생성을 하고 객체간의 의존성을 관리했었으나 프로젝트가 커질수록 코드가 복잡해지고 유지보수가 힘들어지는 단점이 존재. 예를 들어 A 클래스를 정의하고 B 클래스에서 A 클래스의 객체를 만들었을때 A를 수정하니 B에서 오류 발생 잦음

Spring에서는 이상의 문제를 IoC 개념을 통해서 해결. 개발자가 직접 특정 클래스에서 객체를 생성하는게 아니라 Spring IoC 컨테이너에서 객체 생성 자체를 위임. 스프링 컨테이너는 애플리케이션에서 필요한 객체들을 미리 생성하고 필요할 때 특정 클래스에서 주입. 이렇게 스프링 컨테이너에 의해 관리되는 객체가 Bean

그리고 Bean은 싱글톤 스코프로 관리. 그러면 전체를 통틀어 하나의 객체만 생성되는걸 담보하기에 메모리 효율성을 높이고 일관된 상태 유지 가능

## @Bean 애너테이션
`@Bean` 애너테이션은 메서드에 붙여서 사용하며 이 메서드가 반환하는 객체를 스프링 컨테이너에 빈으로 등록

### @Bean 애너테이션 사용 방법
`@Bean`은 주로 `@Configuration`이 붙은 클래스 내부의 메서드에서 사용. `@Configuration`은 해당 클래스가 빈 설정정보를 가지고 있음을 의미(OpenAPI 도입시 애너테이션 확인)

```java
package com.example.cardatabase;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI carDatabaseOpenApi() {
        return new OpenAPI()
                .info(new Info()
                        .title("Car REST API")
                        .description("My car Stock")
                        .version("1.0")
                );
    }
}
```

### @Bean의 사용 여부에 따른 코드 라인의 차이
1. @Bean을 사용하지 않을때의 예시
   - @Bean을 사용하지 않으면 개발자가 직접 객체를 생성하고 관리

```java
public class MyService {
    public void doSomething() {
        System.out.println("이 method가 무슨 짓을 하고 있습니다");
    }
}

public class MyController {
    // 개발자가 직접 메서드 호출하기 위한 객체 생성
    private MyService myService1 = new MyService();
    
    public void handleRequest() {
        myService.doSomething();    // MyController 클래스에서 MyService를 만들고 메서드 호출
    }
}
```
그러면 현재로서는 이상한 점은 없지만 이상의 방식은 의존성 주입(Dependency Injection)을 활용하지 않아 객체간의 결합도가 높아지고 테스트 및 유지 보수 어려움. 즉 MyController 클래스만 테스트를 해보려고 해도 내부에서 MyService 객체를 만듼 MyService 클래스까지 무조건 테스트를 해야해서 문제 발생. 개수가 늘어날수록 테스트 양 증가

2. @Bean을 사용하는 예시
- @Bean을 사용하면 스프링 컨테이너가 MyService 클래스의 객체를 생성하고 관리. 그리고 `@Autowired`를 통해 이 객체를 주입받아 사용

```java
import org.assertj.core.util.diff.myers.MyersDiff;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Controller;

@Configuration
public class AppConfig {
    // MyService 객체를 빈으로 등록 과정
    @Bean
    public MyService myService() {
        return new MySerivce();
    }
}

public class MyService {
    public void doSomething() {
        System.out.println("얘가 뭘 또 합니다");
    }
}

@Controller
public class MyController {
    private final MyService myService;      // 위와의 차이점은 이 클래스에서 객체를 생성하지 않고서 field로 처리했다는 점
    
    // 생성자 주입
    public MyController(MyService myService) {
        this.myService = myService
    }
    
    public void handleRequest() {
        myService.doSomething();
    }
}
```
이상의 예시에서 @Configuration이 붙어있는 AppConfig 클래스는 스프링 빈 구성 클래스로 동작. myService() 메서드에 @Bean 애너테이션을 붙여서 결과값이 MyService의 객체가 되고 이를 스프링 컨테이너에 등록. 이상의 작업이 선행되면 MyController 클래스는 new 키워드 없이 생성자를 통해 바로 스프링 컨테이너로부터 MyService 객체를 전달 받아 사용 가능

그러면 객체가 통째로 하나만 있다는걸 담보할 수 있기에 new를 쓸 때 처럼 객체 개수가 늘어나지 않고 메모리 효율성과 일관성을 가질 수 있으며 MyController - MyService 클래스 간의 결합도를 낮추는 효과

