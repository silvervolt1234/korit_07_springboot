# RESTful API 문서화
- RESTful API는 이를 이용하는 개발자가 그 기능과 작동을 이해할 수 있게 적절히 문서화
- Open API 3를 이용해 이용 가능한 엔드포인트 목록 / 허용 데이터 양식 / API와 상호작용하는 방법 등을 포함

OpenAPI3를 이용한 자동 문서 생성 방식(Swagger 명세)인데 이는 RESTful API를 위한 API 설명 명세서에 해당. RAML도 있으나 한국에서는 잘 사용 안됨

OpenAPI 역시 라이브러리

1. SpringDoc OpenAPI Starter WebMVC UI 사용

`implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2`

상기해야할 점은 외부 라이브러리를 사용하면 Java 자체를 이용하는게 아니여서 의존성 추가가 선행되어야 함. 의존성 추가는 build.gradle에서 진행

2. com.example.cardatabase 패키지에 OpenApiConfig 클래스 생성
```java
package com.example.cardatabase;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI carDatabaseOpenApi() {
        return new OpenAPI()
                .info(new Info()
                        .title("Car REST API")
                        .description("My car Stock")
                        .version("1.0")
                );
    }
}
```
이상의 코드에서 `@Bean`이라는 애너테이션이 존재하고 return new OpenApi.info(); 라는 지점에서 chaining method 개념을 도입했고 거기 new Info() 내에서 객체 생성을 빌더 패턴으로 한 사실에 주목

3. application.properties 수정
```properties
spring.application.name=cardatabase
spring.datasource.url=jdbc:mariadb://localhost:3310/cardb
spring.datasource.username=root
spring.datasource.password=1234
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create-drop
spring.data.rest.basePath=/api
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/api-docs
```

이후 http://localhost:8080/swagger-ui/index.html

# Bean / @Bean
- Spring에서 Bean은 스프링 IoC(Inversion of Control : 제어의 역전) 컨테이너가 관리하는 Java 객체

## Bean의 정의
Spring이 등장 전에는 개발자가 직접 new 키워드를 통한 객체 생성을 하고 객체간의 의존성을 관리했었으나 프로젝트가 커질수록 코드가 복잡해지고 유지보수가 힘들어지는 단점이 존재. 예를 들어 A 클래스를 정의하고 B 클래스에서 A 클래스의 객체를 만들었을때 A를 수정하니 B에서 오류 발생 잦음

Spring에서는 이상의 문제를 IoC 개념을 통해서 해결. 개발자가 직접 특정 클래스에서 객체를 생성하는게 아니라 Spring IoC 컨테이너에서 객체 생성 자체를 위임. 스프링 컨테이너는 애플리케이션에서 필요한 객체들을 미리 생성하고 필요할 때 특정 클래스에서 주입. 이렇게 스프링 컨테이너에 의해 관리되는 객체가 Bean

그리고 Bean은 싱글톤 스코프로 관리. 그러면 전체를 통틀어 하나의 객체만 생성되는걸 담보하기에 메모리 효율성을 높이고 일관된 상태 유지 가능

## @Bean 애너테이션
`@Bean` 애너테이션은 메서드에 붙여서 사용하며 이 메서드가 반환하는 객체를 스프링 컨테이너에 빈으로 등록

### @Bean 애너테이션 사용 방법
`@Bean`은 주로 `@Configuration`이 붙은 클래스 내부의 메서드에서 사용. `@Configuration`은 해당 클래스가 빈 설정정보를 가지고 있음을 의미(OpenAPI 도입시 애너테이션 확인)

```java
package com.example.cardatabase;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI carDatabaseOpenApi() {
        return new OpenAPI()
                .info(new Info()
                        .title("Car REST API")
                        .description("My car Stock")
                        .version("1.0")
                );
    }
}
```

### @Bean의 사용 여부에 따른 코드 라인의 차이
1. @Bean을 사용하지 않을때의 예시
   - @Bean을 사용하지 않으면 개발자가 직접 객체를 생성하고 관리

```java
public class MyService {
    public void doSomething() {
        System.out.println("이 method가 무슨 짓을 하고 있습니다");
    }
}

public class MyController {
    // 개발자가 직접 메서드 호출하기 위한 객체 생성
    private MyService myService1 = new MyService();
    
    public void handleRequest() {
        myService.doSomething();    // MyController 클래스에서 MyService를 만들고 메서드 호출
    }
}
```
그러면 현재로서는 이상한 점은 없지만 이상의 방식은 의존성 주입(Dependency Injection)을 활용하지 않아 객체간의 결합도가 높아지고 테스트 및 유지 보수 어려움. 즉 MyController 클래스만 테스트를 해보려고 해도 내부에서 MyService 객체를 만듼 MyService 클래스까지 무조건 테스트를 해야해서 문제 발생. 개수가 늘어날수록 테스트 양 증가

2. @Bean을 사용하는 예시
- @Bean을 사용하면 스프링 컨테이너가 MyService 클래스의 객체를 생성하고 관리. 그리고 `@Autowired`를 통해 이 객체를 주입받아 사용

```java
import org.assertj.core.util.diff.myers.MyersDiff;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Controller;

@Configuration
public class AppConfig {
    // MyService 객체를 빈으로 등록 과정
    @Bean
    public MyService myService() {
        return new MySerivce();
    }
}

public class MyService {
    public void doSomething() {
        System.out.println("얘가 뭘 또 합니다");
    }
}

@Controller
public class MyController {
    private final MyService myService;      // 위와의 차이점은 이 클래스에서 객체를 생성하지 않고서 field로 처리했다는 점
    
    // 생성자 주입
    public MyController(MyService myService) {
        this.myService = myService
    }
    
    public void handleRequest() {
        myService.doSomething();
    }
}
```
이상의 예시에서 @Configuration이 붙어있는 AppConfig 클래스는 스프링 빈 구성 클래스로 동작. myService() 메서드에 @Bean 애너테이션을 붙여서 결과값이 MyService의 객체가 되고 이를 스프링 컨테이너에 등록. 이상의 작업이 선행되면 MyController 클래스는 new 키워드 없이 생성자를 통해 바로 스프링 컨테이너로부터 MyService 객체를 전달 받아 사용 가능

그러면 객체가 통째로 하나만 있다는걸 담보할 수 있기에 new를 쓸 때 처럼 객체 개수가 늘어나지 않고 메모리 효율성과 일관성을 가질 수 있으며 MyController - MyService 클래스 간의 결합도를 낮추는 효과

# 백엔드 보호
1. Spring Security
2. JWT를 이용한 백엔드 보호
3. Role-based 보호


## Spring Security
- 자체 기능
  1. 인메모리 사용자 하나를 포함하는 AuthenticationManger 빈. 사용자 이름은 user고 암호는 Console에 실행할때마다 출력
  2. `/css`, `/images` 같은 일반적인 정적 리소스 위치의 경로를 무시. 다른 모든 엔드 포인트에 대한 HTTP 기본 인증
  3. 스프링 ApplicationEventPublisher 인터페이스로 게시되는 보호 이벤트
  4. HSTS, XSS, CSRF를 비롯한 일반적인 저수준 기능을 기본 활성화
  5. 자동 생성되는 기본 로그인 페이지

### Spring Security의 도입
1. build.gradle에 의존성 추가
   - mvn에서
     Spring Boot Starter Security 검색 후 모델 적용(버전 필수 삭제)
```java
implementation 'org.springframework.boot:spring-boot-starter-security'
testImplementation 'org.springframework.boot:spring-boot-starter-security'
```

http://localhost:8080으로 접속시 알아서 http://localhost:8080/login으로 이동하는데 이상의 과정에서 username : user / password : 콘솔 비밀먼호 로 접속하면 http://localhost:8080?continue로 이동

현재는 http://localhost:8080에 입력한게 없어서 whitelabel page가 나오는데 http://localhost:8080/api/cars 등으로 접속하면 데이터가 이전과 같이 나올시 정상 처리

Spring Security 작동 방식을 구성하려면 Config class 추가. 특정 역할이나 사용자가 접근 가능한 URL 또는 URL 패턴을 정의 가능하고 인증 메커니즘, 로그인 프로세스, 세션 관리 등을 정의하는 클래스에 해당

그래서 com.example.cardatabase 패키지에 SecurityConfig 클래스 생성
```java
package com.example.cardatabase;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public InMemoryUserDetailsManager userDetailsManager() {
        UserDetails user = User.builder()
                .username("user")
                .password(passwordEncoder().encode("password"))
                .roles("USER")
                .build();
        return new InMemoryUserDetailsManager(user);
    }
    // 암호화를 위한 과정
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```
이상의 SecurityConfig의 @Configuration, @EnableWebSecurity 애너테이션은 기본 웹 보호 구성을 해젷며 이 클래스에서 자체 Config를 정의하게 한다 -> 애초에 Spring Security에서 지우나하는 보호 Config 관련 설정들이 있고 커스텀하는 의미

인메모리 사용자를 추가했는게 @Bean을 통해 객체를 스프링 컨테이너에 등록했고 또한 PasswordEncoder 클래스의 객체를 생성해 앞으로 암호 입력을 해도 DB에선 암호화된 상태

이상의 코드 구현에서는 결과적으로 username이 user / 비밀번호가 password(암호화 완료) / 역할은 USER로 정의된 인메모리 사용자 생성(builder pattern으로 생성한것에 주목)

인메모리 사용자를 만는건 개발단계에서는 괜찮으나 운영 환경에서는 사용자 정보를 DB에 저장. 그리고 유저 정보를 DB에 저장하려면 엔티티와 리포지터리 필요. 그리고 암호 역시 일반 텍스트로 DB에 저장하느게 아니라 암호화 과정 요구됨

1. AppUser 생성
```java
package com.example.cardatabase.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

@Entity
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
@Getter
@Setter
public class AppUser {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(nullable = false, updatable = false)
    private Long id;

    @Column(nullable = false, unique = true)
    private final String username;

    @Column(nullable = false)
    private final String password;

    @Column(nullable = false)
    private final String role;
}
```
이상의 코드에서 처음으로 @Column 사용을 통한 구체적인 컬럼 설정이 이루어 졌는데 name =  속성으로 컬럼명을 새로 커스텀하는 것부터 nullable로 null 허용 여부 / unique를 통해서 다른 row들과의 차이를 식별할건지 지정 가능

username의 경우 일치하게되면 users들이 서로 다른 사람인걸 인지할 수 어뵤기에 username은 unique 설정을 비밀번호의 경우 인코딩이 되기도 하기에 unique=false로 설정. 특정 컬럼이 어떤 속성을 지니는지는 설계 단계에서 고민

2. AppUserRepository 생성
```java
package com.example.cardatabase.domain;

import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AppUserRepository extends JpaRepository<AppUser, Long> {
Optional<AppUser> findByUsername(String username);
}
```
위 코드에서는 여태까지 CarRepository에 추상 메서드들을 정의할 때는 결과값들이 기본적으로 복수로 나오기 때문에 List 자료형을 썻지만 findByUsername()의 경우 username 필드가 unique = true니 결과값이 하나거 0개만 나오니 return type을 list로 설정하는건 적절하지 않은 선택지

그러면 AppUser를 return 하는건 적절하지 않지만 예전에는
```java
public AppUser findByusername(String username) {
    if (username이 DB 내에 일치하는 username이 있다면){
        return 일치 객체
    }
    return null;
}
```
같은 로직이 필요. 하지만 인터페이스니 일반 메서드를 작성하지 못해서 AppUser를 return type으로 작성하면 AppUserRepository를 import 하는 곳 마다 위의 로직을 복사해야 함

그래서 Optional이라는 클래스 출시. null 값으로 return 되더라도 오류 X

3. service 패키지 생성
4. UserDetailsServiceImpl 생성
  - Impl = implement
  - implements의 의미는 특정 인터페이스의 추상 메서드들을 강제 구현하기 위한 명령어
  - 그래서 특정 클래스명이 Impl로 끝나면 어떠한 인터페이스를 구현한 클래스로 해석
  - 인터페이스명Impl.java의 형태로 작성

```java
package com.example.cardatabase.service;

import com.example.cardatabase.domain.AppUser;
import com.example.cardatabase.domain.AppUserRepository;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.User.UserBuilder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    private final AppUserRepository userRepository;

    public UserDetailsServiceImpl(AppUserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<AppUser> user = userRepository.findByUsername(username);

        UserBuilder builder = null;
        if (user.isPresent()) { // 이하의 실행문이 실행되면 user에 AppUser가 있다는 의미
            AppUser currentUser = user.get();
            builder = User.withUsername(username);
            builder.password(currentUser.getPassword());
            builder.roles(currentUser.getRole());
        } else {
            throw new UsernameNotFoundException("User not found.");
        }
        
        return builder.build();
    }
}
```
이상의 코드에서 생기는 의문점은 멀쩡하게 있는 AppUser 클래스의 객체인 user를 그대로 쓰는게 아니라 UserBuilder 라는 다른 클래스의 객체인 builder를 선언하고 내부에 AppUser의 field 값들을 대입하는 로직이 있다는걸 확인 가능

인터페이스 내에는 추상 메서드만 존재하고 이를 구현하는 클래스는 인터페이스 내에 있는 추상 메서드를 강제로 구현(implement)해야만 한다. 이미 AppUser라는 entity 클래스를 만들기 이전에 있는 인터페이스를 구현했기에 거기에 있는 추상 메서드들의 return type은 AppUser가 아니다

또한 다른 개발자들도 이 인터페이슬 구현해야하기에 특정 프로젝트에 맞는 entity 클래스보단 보편적인 return type 요구

그렇게 추상 메서드의 return type이 고정되있어서  만든 entity class의 객체를 UserDetails 클래스의 객체 형태로 대입해줄 필요가 있기에 i문 내부의 실행문에 해당 로직 존재

- 이상의 코드는 Spring Security 인증 처리 시 DB에서 사용자를 가져오기 위해서 UserServiceDetailsImpl 클래스에 AppRepository 클래스를 주입. 그리고 AppUserRepository에는 findByUsername() 메서드를 Optional 결과값이 나오게 작성. 
- 그래서 Optional에 딸린 메서드인 isPresent() 메서드를 통해 특정 username을 지닌 AppUser가 있는지 체크 가능. 그래서 user가 없다면 UsernameNotFoundException 예외를 발생 시켜 투척(throw)
- 강제 구현하도록 된 loadUserByname() 메서드는 인증