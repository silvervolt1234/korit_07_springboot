# MVC Pattern
- 정의 : 애플리케이션의 구조를 모델, 뷰, 컨트롤러라는 세 부분으로 분리해 개발하는 방식

## MVC 패턴이란
사용자 인터페이스를 갖춘 애플리케이션을 구조화하는 소프트웨어 디자인 패턴. 이는 비즈니스 로직(데이터 처리), 사용자 인터페이스(화면 표시), 그리고 둘을 연결하는 제어 로직을 명확히 분리하는 것이 목표
- MVC의 구성 요소
  - Model
    - 역할 : 데이터의 비즈니스 로직을 담당. 애플리케이션이 무엇을 하는지에 대한 핵심. 데이터의 저장, 처리, 조회, 변경 등의 작업을 수행하고 사용자에게 보여줄 데이터 자체를 저장
    - SpringBoot 상의 형태 : Service 클래스, Repository(DA0) 클래스, 혹은 데이터 객체(DTO 또는 Entity) 등이 해당
  - View
    - 역할 : 사용자에게 데이터를 시작적으로 보여주는 역할. 사용자의 입력(클릭, 폼 제출 등)을 받고 그 결과를 화면에 렌더링. 어떻게를 보여줄지 담당(HTML / CSS 부분)
    - SpringBoot 상의 형태 : HTML / CSS / JS를 통해 구성된 페이지들이고 SpringBoot는 주로 Thymeleaf, JSP(Java Server Page) 등의 템플릿 엔진을 사용하거나 REST API는 JSON/XML 등의 데이터 형식 응답. 여기서는 React로 연결
  - Controller
    - 역할 : 사용자의 요청을 받아 처리하고 Model과 View를 연결하는 중재자 역할. 사용자가 무엇을 할지에 대한 요청을 분석하고 Model에 필요한 작업을 지시 후 결과를 바탕으로 적절한 View를 선택해 사용자에게 응답
    - SpringBoot 상의 형태 : `@Contoller, @RestController` 애너테이션이 붙은 클래스. `@RequestMapping` 등의 애너테이션으로 특정 URL 요청을 처리하는 메서드 정의
  
## Spring MVC의 동작 원리(요청 처리 흐름)
SpringBoot는 내부적으로 Spring MVC 프레임워크를 사영해 MVC 패턴을 구현. 모든 요청을 처리하는 중앙 집중식 프론트 컨트롤러(Front Controller) 방식이 핵심

DispatcherServlet(디스패처 서블릿) - Spring MVC의 Core
- 웹 애플리케이션으로 들어오는 모든 HTTP 요청을 가장 먼저 받아서 처리하는 프론트 컨트롤러 역할. SpringBoot는 내장된 웹 서버를 사용하고 별도의 복잡한 설정 없이 DispatcherServlet이 자동 설정(Spring으로 개발시 이 서버 설정도 개발자가 수행) 

- 요청 처리의 단계
  - 사용자가 웹 르라우저에서 특정 URL을 입력하거나 버튼 클릭시(HTTP 요청 발생)부터 화면에 결과가 표시될 때 까지의 과정
  1. 요청 수신(Request Reception) : 
    - 사용자의 요청(ex : `GET /users/1`)이 `DispatcherServlet`으로 전달
  2. 핸들러 매핑(Handler Mapping) :
    - `DispatcherServlet`은 `HandlerMapping`에게 요청 URL을 처리할 적절한 Controller를 찾으라고 요청
    - `HandlerMapping`은 주로 `@Controller` 클래스의 `@RequestMapping` 애너테이션을 확인해서 요청 처리 특정 메서드 찾기
  3. Controller 실행 :
    - `DispatcherServlet`은 찾은 Controller의 메서드를 `HandlerAdapter`를 통해 실행
    - Controller는 요청을 분석해 Service/Repository(Model) 게층에 데이터 처리(비즈니스 로직)를 요청
    - ex) 사용자 정보 조회 요청은 Model 계층에 데이터베이스로부터 해당 정보 가져오기
  4. ModelView 반환 :
    - Controller의 처리 결과를 담은 Model 데이터와 View의 논리적 이름을 포함하는 ModelAndView 객체(또는 이름만, 또는 Model 데이터만)를 `DispatcherServlet`에게 return
  5. View 이름 해석(View Resolution) :
    - `DispatcherServlet`은 `ViewResolver`에게 View의 논리적 이름을 전달해 실제 렌더링을 담당할 View 객체를 찾게 요청
  6. View 렌더링 및 응답(View Rendering & Response) :
    - `DispatcherServlet`는 최종적으로 View 객체에게 Model 데이터를 전달하고 렌더링 요청
    - View는 Model 데이터를 사용해 최종적인 HTML 응답 페이지를 생성하고 이 응답은 `DispatcherServlet`을 거쳐 사용자에게 전송

    - `Get user/1`이면 DB 상에서의 user_id가 1인 데이터로 HTML 문서를 만들고 2면 user_id가 2인 데이터로 HTML 문서를 만들어 브라우저 출력
  
## SpringBoot 3.5.6에서의 MVC 특징 및 구현 예시
SpringBoot는 Spring MVC를 자동 처리하기에 개발자는 핵심 로직에만 집중 가능. 3.xx.xx 버전은 Java 17을 기반으로 하고 설정 간소화와 편의성이 증가

- Controller 구현 예시

```java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@Controller // 해당 클래스가 Controller임을 선언
public class UserController {
    private final UserSerivce userSerivce;  // Model과의 상호작용을 위한 Service 주입(Injection)

    // 생성자 주입
    public UserController(UserService userService) {
        this.userSerivce = userService;
    }

    // GET 요청으로 /users/123
    @GetMapping("/users/{userId}")
    public String getUserDetail(@PathVariable Long userId, Model model) {
        // 1. Controller는 Model(Service)에 데이터 요청
        User user = userSerivce.findUserById(userId);
        
        // 2. Controller는 Model 데이터를 View에 전달하기 위해 Model 객체 담기
        model.addAttribute("user", user);
        model.addAttribute("pageTitle", "사용자 상세 정보");
        
        // 3. Controller는 View의 논리적 이름을 return
        // : (ViewResolver가 user-detail에 해당하는 템플릿)
        return "user-detail";
    }
}
```
위 코드는 Thymeleaf를 활용해 SpringBoot와 HTML 문서를 연결하는 방식

- Model(Service 계층) 구현 예시
Controller의 요청을 받아 실제 비즈니스 로직을 처리하는 영역 - Java의 제어문을 배운 이유가 여기에

```java
import org.h2.engine.User;
import org.springframework.stereotype.Service;

@Service    // 해당 클래스가 Service(Model)임을 명시
public class UserService {
    private final UserRepository userRepository;
    
    public userService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User findByUserById(Long id) {
        // UserRepository에 담겨 잇는 DB를 조회해 Java에서 쓸 수 있게
        User user = userRepository.findById(id);
        if(id == user.getId()) {
            return user;
        }
        return null;
    }
}
```

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title th:text="${pageTitle}">사용자 상세</title>
</head>
<body>
<h1>사용자 상세 정보</h1>

<p>ID: <span th:text="${user.id}">123</span></p>
<p>이름: <span th:text="${user.name}">김철수</span></p>
<p>이메일: <span th:text="${user.email}">chulsoo@email.com</span></p>

<a href="/">돌아가기</a>
</body>
</html>
```

## MVC 패턴 사용의 장점
1. 관심사 분리(Separation of Concerns) :
  - 데이터 처리(Model), 화면 표시(View), 요청 처리(Controller)가 명확히 분리되서 각 부부늘 독립적으로 개발하고 수정
    - 보여주는 부분 오류 -> View 수정
    - DB가 못 가져옴 -> Repository of Service 수정
    - 요청 엔드 포인트 오류 -> Controller 수정 등
2. 높은 재사용성 :
  - 동일한 Model(비즈니스 로직)을 사용해 여러 View(웹페이지, 모바일 앱, REST API)를 만들 수 있다(사이즈 줄여서 모바일 웹페이지/회원가입 창을 이용한 로그인 페이지 등)
3. 유지 보수의 용이성 :
  - 회면 디자인이 변경되도 Controller나 Model 코드는 거의 수정할 필요가 없어서 반대로 비즈니스 로직이 바뀌어도 View에 미치는 영향이 최소화
  - ex) 카카오톡 9월 패치. DB에 프로필 사진들이 있는데 가장 최근 id를 기준으로 프로필 사진에 나머지 사진들을 커버 사진으로 넣은걸 인스타식으로 수정. DB에 있는 부분들의 코드 수정이 많지는 않음
4. 테스트 용이성 :
  - 각 구성 요소가 독립적이기에 단위 테스트를 쉽게 작성하고 수행 가능(GET 요청만 확인하거나 등). 특히 Controller와 Model 비즈니스 로직은 View와 독립적인 테스트 가능(postman, HediSQL로 CRUD 테스트 마무리)
5. 병렬 개발 가능
  - 프론트엔드 개발자(View)와 백엔드 개발자(Controller, Model)가 서로의 작업에 큰 영향은 없으면서 동시에 개발이 가능해 속도가 향상

## 요약
1. MVC는 Model / View / Controller로 코드를 분리하는 디자인 패턴
2. `DispatcherServlet`이라는 프론트 컨트롤러로 요청 처리
3. Controller는 요청을 받고 Model을 호출해 View를 선택하는 중재자 역할
  - View에서 요청(Request) -> Controller 내부의 코드에서 Service 호출 -> Service가 Repository를 호출해 DB 관련 정보 습득 후 데이터 처리 -> Controller로 보내기 -> Controller가 적절한 .html 문서 응답(Response) => 현재 RepositoryEntity 사용
4. Model은 비즈니스 로직과 데이터를 담당(Entity - Repository - Service)


# Spring Initializer를 통한 cardatabase4 생성
1. Car / CarRepository 생성
  - 그런데 CarRepository 부분에서 JpaRepository 상속이 안됨 -> `implementation 'org.springframework.boot:spring-boot-starter-data-jpa'`
  - 여전히 오류 발생 -> Car의 field로 Owner가 있는데 Owner 객체가 없기에
2. Owner / OwnerRepository 생성
  - 실행 불가능 -> application.properties 설정 x /  build.gradele에 mariadb 의존성 x
  - 이상의 설정 마무리 후 스프링부트 애플리케이션 실행 결과값
    - HeidiSql에서 `SELECT * FROM car;`의 결과는 row = 0인 테이블 생성
  - Controller 파트를 작성하지 않아서 HeidiSQL은 데이터 확인 및 추가는 가능하나 postman은 불가능
3. 위 과정에서 발생한 문제로 MVC 패턴을 만들어야지 postman에서 CRUD 가능. 그러면 Model에서 만든 Entity와 Repository를 제외하고 Service 파트를 만들고 Controller에 해당하는 Controller도 생성
  - 루트 프로젝트 패키지에 service 패키지를 생성 후 CarService 생성
4. 페이지를 보여주게 하기 위해 React와 연결할것이므로 View와 연결이 아닌 ResponseEntity와 연결하기 위한 CarController 작성

```java
// CarService
package com.example.cardatabase4.service;

import com.example.cardatabase4.domain.Car;
import com.example.cardatabase4.domain.CarRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class CarService {
    private final CarRepository carRepository;

    public CarService(CarRepository carRepository) {
        this.carRepository = carRepository;
    }

    // 모든 자동차 목록을 조회한다고 가정
    public List<Car> getCars() {
        return carRepository.findAll();
    }
    
    // 새로운 자동차 저장
    public Car addCar(Car car) {
        return carRepository.save(car);
    }
}

// CarController
package com.example.cardatabase4.web;

import com.example.cardatabase4.domain.Car;
import com.example.cardatabase4.service.CarService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api")
public class CarController {
  private final CarService carService;

  public CarController(CarService carService) {
    this.carService = carService;
  }

  // 1. 모든 자동차 정보 조회 (GET /api/cars))
  @GetMapping("/cars")
  public List<Car> getCars() {
    return carService.getCars();
  }

  // 2. 차량 한 대 추가 (POST /api/cars)
  @PostMapping("/cars")
  public ResponseEntity<Car> addCar(@RequestBody Car car) {
    Car savedCar = carService.addCar(car);

    return new ResponseEntity<>(savedCar, HttpStatus.CREATED);
  }
}
```

# .map()
함수형 프로그래밍의 핵심 개념 중 하나로 Collection이나 컨테이너 객체 내부의 각 요소를 변환하여 새로운 컬렉션이나 컨테이너를 생성하는데 사용

## .map()의 전반적 정의
- 목적 : 컨테이너 객체(예: Stream, Optional) 내부의 값을 다른 타입 또는 형태의 값으로 변환해 새 컨테이너를 반환
- 각 element에 적용될 변환 함수(Function을 argument로 받기) -> 람다식이 필수적
- 원본 데이터는 변경하지 않고 변환된 element를 담는 새로운 객체를 만들어냄(함수형 프로그래밍의 특징)

## .map()이 존재하는 주요 자료형(Java) 기준
1. `Optional<T>` : 값이 있을수도 없을수도 있는 단일 컨테이너
  - 역할 : 값이 존재할 경우에만 그 값을 변환하고 그 결과를 다시 `Optional`로 감싸서 return. 값이 비어있는 경우 빈 Optional을 Return
  - 예시 : `Optional<User>`를 `Optional<String>`으로 변환시 사용 등
2. `Stream<T>` : 데이터소스(컬렉션, 배열 등)에서 element를 처리하기 위한 파이프라인 구축 용으로 사용
  - 역할 : Stream 내의 모든 element에 대해 argument로 들어온 변환 함수(람다식 형태)를 적용해 변환된 element를 담는 새로운 스트림 생성
  - 예시 : `Stream<String>`(단어 목록)을 `Stream<Intger>`(각 단어의 길이)로 변환
3. Collection : List, Set 등의 자료 구조
  - 역할 : 대부분의 객체 지향 언어에서 컬렉션이 자체 .map()을 지원하는데 Java에서는 컬렉션을 직접 반환하기 위해 Steam 거침

## 예시
1. Stream에서 사용
```java
public class StreamMapExample {
  public static void main(String[] args) {
    List<Integer> numbers = Arrays.asList(1,2,3,4,5);
    
    // 1. stream 형태로 바꾸는 작업
    List<Integer> squaredNumbers = numbers.stream()
    // 2. map()으로 각 element(1,2,3,4,5)에 n * n 을 하게 람다식 적용
        .map(n -> n * n)
    // 3. 현재는 stream이니 다시 List로 변환
        .collect(Collectors.toList());

    System.out.println(SquaredNumbers); // 결과값 [1,4,9,16,25]
    System.out.println(numbers);        // 결과값 : [1,2,3,4,5]
  }
}
```

2. Optional에서 사용(값의 안전한 접근 및 변환)
예를 들어 User 객체에서 이메일 주소만 가지고 오는데 User 객체가 존재할때만 동작하게 보장
```java
class User {
    private String email;
    public User(String email) {
        this.email = email;
    }
    public String getEmail() {
        return email;
    }
}

public class OptionalMapExample {
    // 사용자를 찾지 못했으면 비어잇는 Optional 반환 메서드 정의
    // extends JpaRepository로 여태 사용 불가
    public static Optional<User> findUser(boolean found) {
        // return에 삼항 연산자
        return found ? Optional.of(new User("kim@test.com"))    
                : Optional.empty(); 
    }

    public static void main(String[] args) {
        // 1. User 객체가 있는 경우를 예시로
        String emailFound = findUser(true)
        // User 객체가 있으면 getEmail() 메서드를 호출해 String으로 변환되게 map() 적용
        .map(User:: getEmail)
        // Optional<String>이 비면 "N/A" 반환
        .orElse("N/A");

        System.out.println("E-mail : " + emailFound);   // 결과값: E-mail : kim@test.com

        String emailFound = findUser(false)
        // User 객체가 있으면 getEmail() 메서드를 호출해 String으로 변환되게 map() 적용
        .map(User:: getEmail)
        // Optional<String>이 비면 "N/A" 반환
        .orElse("N/A");

        System.out.println("E-mail : " + emailFound);   // 결과값 : N/A
    }
}
```

Owner Service/Controller에 구현 목록 -> Owner 전체 조회 / id별 조회 / Owner 객체 추가 / Owner 객체 삭제 / Owner 객체 수정