# 백엔드 환경 및 툴 설정
1. intellij install
2. gradle

## gradle의 이해
- 소프트웨어 개발 프로세스를 간소화 및 통합하는 빓드 자도화 툴로, 프로젝트 의존성을 관리하고 빌드 프로세스를 처리
- SpringBoot와 함께 메이븐(Maven)이라는 다른 프로젝트 관리 도구도 쓸 수 있지만 gradle이 가시성 더 좋음
- gradle의 구성은 프로젝트의 build.gradle 파일에서 수행. 이 파일은 프로젝트이 특정 요구 사항에 맞춰 사용자가 지정 가능하며 소프트웨어 빌드, 테스트 및 배포와 같은 작업을 자동화하는데 이용 가능
- 이상의 파일은 일반적으로 프로젝트 컴파일에 필요한 외부 라이브러리 및 프레임워크 등 프로젝트의 의존성에 대한 정보를 포함(Java를 할 때 Lombok 설치)
- build.gradle 파일을 작성 시 Kotlin 또는 Groovy 프로그래밍 언어를 사용 가능한데 Groovy로 선택

### 일반적인 build.gradle 내부의 항목
1. 플러그인(plugins) : 플러그인 블록은 프로젝트에서 쓰이는 gradle 플러그인을 정의하는 곳이며 롬복뿐만 아니라 SpringBoot도 명시
2. 리포지터리(repository) : 의존성을 해결하는 데 쓰이는 의존성 리포지터리를 정의. gradle이 의존성을 가져오기 위해 Maven Central 리포지터리를 사용
3. 의존성(dependencies) : 프로젝트에서 사용하는 의존성 지정
4. 태스크(tasks) : 테스트 등의 빌드 프로세스의 일부인 태스크 지정

### 스프링 이니셜라이저 사용
https://start.spring.io

1. Spring Web : Web 관련 설정을 default로 가지는 의존성
2. Spring Boot Dev Tools : 제동 재시작 기능을 제공하는 의존성으로 변경 내용을 저장할 때마다 애플리케이션이 자동 재시작되서 유용

```java
package com.example.cardatabase;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CarDataBaseApplication {

	public static void main(String[] args) {
		SpringApplication.run(CarDataBaseApplication.class, args);
	}
}
```
이상의 main 에서 처음 보는 애너테이션인 `@SpringBootAppliacation`이 있는데 여러 애너테이션의 조합으로 이루어진것으로 필요한 것만 정리
1. @EnableAutoConfiguration
    - 스프링부트의 자동 구성을 활성화. 프로젝트가 의존성에 따라 자동 구성되는데 spring-boot-starter-web 의존성이 있다면 스프링 부트는 사용자가 웹 애플리케이션을 개발중이라 가정하고 그에 따라 애플리케이션 설정
2. @ComponentScan
    - 스프링부트 컴포넌트 컴색으로 애플리케이션의 모든 컴포넌트 첮게 하기
3. @Configuration
    - Bean 정의를 제공하는 소스로 쓸 수 있는 클래스 지정

### Spring Boot Dev Tools
- 이상의 의존성은 애플리케이션 개발 프로세스를 간략화하는 의존성으로 가장 중요한건 클래스의 경로 파일이 수정될 때마다 스프링부트 애플리케이션을 자동 재시작

### Logging / Problem-Solution
- 로깅은 애플리케이션의 흐름을 모니터링하는데 사용 가능하고 예기치 않은 오류를 포착 가능. SpringBootStarter 패키지는 별도의 구성 없이 로깅에 이용 가능한 LogBack이 존재
- 로그백은 SLF4J(Simple Logging Facade For Java)를 기본 인터페이스
```java
package com.example.cardatabase;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CarDataBaseApplication {
	private static final Logger logger = LoggerFactory.getLogger(
			CardatabaseApplication.class
	);

	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
		logger.info("Application Started! / 애플리케이션이 실행되었습니다");
	}
}
```
이상에서 주의할 점은 Logger 하나 import 할 때마다 동일한 이름을 지닌 클래스 / 인터페이스가 많기에 import 경로 설정 중요

logger.info() 메서드는 로그 메세지를 콘솔에 출력. 그리고 로깅 수준에는 TRACE / DEBUG / INFO / WARN / ERROR / FATAL / OFF 7 가지로 나뉘고 이를 application.properties 에서 설정 가능. resources 폴더에 위치

`logging.level.root=DEBUG`로 작성하면 로그 수준이 DEBUG 및 그 이상(= DEBUG / INFO / WARN / ERROR)에 해당하는 로그 메세지 출력

다시 재시작하면 TRACE 관련 메세지 미표기. 별도로 지정하지 않은 default 로깅 수준은 INFO에 해당

스프링부트의 기본 port 번호는 8080이고 코드를 수정했을 때 바로 실행을 시켜 port가 겹쳐 실행 불가능한 케이스가 많기에 현재는 코드 수정 후에 종료를 시행

port 구성을 확인하면
~~~
SpringBoot : 8080
MariaDB : 3310
~~~

# 의존성 주입(Dependency Injection)
## 정의
- 다른 객체에 의존하는 객체를 만들 수 있는 소프트웨어 개발 기법
- 클래스간의 상호 작용을 도우며 동시에 클래스를 독립적 유지
- 의존성 주입의 세 가지 클래스 유형
   1. 서비스(Service) : 클라이언트가 이용활 수 있는 클래스(의존성)
   2. 클라이언트(Client) : 의존성을 이용하는 클래스
   3. 주입기(Injector) : 의존성(서비스)을 의존 클래스(클라이언트)에 전달

의존성 주입을 통해 클래스를 느슨하게 연결하는것이 가능. 즉, 클라이너트 의존성의 생성이 클라이ㄴ언트의 작동과 분리되 단위 테스트 용이

일반적인 형태의 객체 생성 과정
```java
public class Car { 
   // 필드 정의
   private Owner owner;
   // 생성자
   public Car() {
       owner = new Owner();
   }
}
```
이상의 코드는 클라이언트 클래스인 Car가 서비스 클래스(Owner)의 객체를 생성하기에 의존성 주입 x

```java
public class Car {
   private Owner owner;
   public Car(Owner owner) {
       this.owner = owner;
   }
}

public class CarMain{
   public static void main(String[] args) {
      Car car1 = new Car(new Owner());
      // 혹은
      Owner owner2 = new Owner();
      Car car2 = new Car(owner2);
   }
}
```
이상의 코드는 서비스 객체가 클라이언트 클래스에서 직접 생성되지 않고 클래스 생성자에서 매개변수로 전달되는 예시

여기서 Client class가 Car고 의존서에 해당하는 것이 Owner 라는 점에 유의하고 해석

또한 서비스 클래스는 추상 클래스일 수도 있고 이 경우 클라이언트 클래스에서 해당 클래스의 어떤 구현이든 이용할 수 있고 테스트 중에는 Mock 사용가능

## 의존성 주입 유형
1. 생성자(Constructor) 주입 : 
의존성이 클라이언트 클래스 생성자에게 전달되는 방식. 생성자 주입의 예시는 Car 코드에서 확인 가능.
생성자 주입은 필수 의존성으로 주로 이용. 모든 의존성은 클래스 생성자를 이용해 제공되며 필수 의존성 없이 객체 생성 불가(=매개변수 생성자 이용)

2. 세터(Setter) 주입 : 의존성이 세터로 제공되는 방식
```java
public class Car {
    private Owner owner;

   public static void setOwner(Owner owner) {
      this.owner = owner;
   }
}
```
이상의 세터 주입은 아무런 의존성이 없어도 객체 생성이 되서 더 유연. 이 접근 방식은 선택적 의존성을 허용

의존성 주입은 코드의 의존성을 줄이고 코드를 재사용하기 쉽게 구성

## 스브링부트에서의 의존성 주입 이용
스프링 프레임워크에서 의존성 주입은 스프링  ApplicationContext를 통해 구성. 이는 객체(bean)과 객체의 의존성을 생성하고 관리

스프링부트 애플리케이션 클래스를 검색해 특정 애너테이션(@Service / @Repository / @Controller 등)이 있는 클래스를 스프링빈으로 등록. 의존성 주입시 이러한 빈을 주입 가능

1. 생성자 주입
   - 생성자를 통해 의존성 주입. 객체가 생성될 때 필요한 모든 의존성을 반드시 이용하게 되서 가장 권장
   - 가장 보편적인 상황은 특정 작업을 위해 DB에 대한 접근이 필요한 경우 repository 클래스 이용
```java
public class Car {
    private final CarRepository carRepository;
    
    public Car(CarRepository carRepository) {
        this.carRepositroy = carRepository;
    }
    // DB 상에서 CarRepository에 있는 모든 자동차 목록 추출
    carRepository.findAll(); // SELECT * FROM car;
    carRepository.findOwners();
}
```
중요한 것은 .findAll()이 메서드명이 고정

그러나 클래스에 생성자가 여러개면 `@AutoWired` 애너테이션을 이용해 의존성 주입에 이용되는 생성자 정의
```java
public class Car {
    private final CarRepository carRepository;

    // 의존성 주입에 이용하는 생성자
    @AutoWired
    public Car(CarRepository carRepository) {
        this.carRepositroy = carRepository;
    }
}
```

2. 세터 주입 : 의존성은 세터 메서드를 통해 주입. 세터 주입은 선택적 의존성이 있거나(런타임 실행 중)에 의존성을 수정하려는 경우 유용
```java
@Service
public Class AppUserService {
    // 필드 정의
    private AppUserRepository userRepository;
    
    @AutoWired
    public void setUserRepository(AppUserRepository userRepository) {
        this.userRepository = userRepository;
    }
    // 이상의 코드가 일반적인 setter() / call2()
    // userRepository를 이용한 다른 메서드들 사용 가능(ex.volumeUpButton의 예시)
    // userRepository.findAll();로 전체 목록을 불러와 user 숫자 카운트 등
}
```

3. 필드 주입 : 의존성을 필드에 직접 주입. 의존성을 사용하지 못하면 런타임 에러가 발생 가능하고 테스트를 위해 모의 객체를 만드는게 아니라 새로운 객체가 만들어져 테스트 난이도 높음
```java
@Service
public class CarDatabaseService implements CarService {
    // 여기에 Car 데이터베이스 서비스가 존재한다고 가정
}

public class CarController {
     @AutoWired
     private CarDatabaseService carDatabaseService;
)
```

# JPA를 이용한 데이터베이스 생성 및 접근
SpringBoot와 함께 JPA(Jakarta Persistence API / Java Persistence API)를 이용하는 방법 및 Entity 클래스로 데이터베이스를 정의(=SQL)

H2 인메모리 데이터베이스와 H2에서 MariaDB로 이동. 동시에 CRUD Repository를 생성하고 데이터베이스의 테이블과 엔티티 클래스의 관계 학습

## ORM / JPA / Hibernate 개념
ORM / JPA는 RDB를 처리하기 위해 소프트웨어 개발에 널리 이용되는 기술로 복잡한 SQL 쿼리를 작성할 필요 없이 Java 개발자에게 친숙한 형태로 DB 조작. ORM / JPA는 SQL 코드 작성 및 디버깅 소요 시간 감소

대부분의 JPA 구현체들은 Java Entity 클래스를 바탕으로 DB의 스키마를 자동 생성

1. ORM(Object Relational Mapping) :
객체지향 프로그래밍 패러다임을 이용해 DB를 가져오고 매핑할 수 있는 기술. ORM은 데이터베이스 구조마다 객체지향 개념을 바탕에 둬서 Java 개발자가 SQL까지 건들일 필요성을 줄이는 장점 존재.
그리고 ORM으로 개발하면 DB와 독맂적으로 구동되기 때문에 개발자가 이용하는 DBMS가 무엇인지에 따라 달라지는 SQL문에 걱정할 필요 X -> DB 이식 쉬움

2. JPA : 
Java 개발자를 위한 객체-관계형 매핑을 제공(ORM의 더 구체적인 버전). JPA 엔티티는 데이터베이스 테이블의 구조를 나타내는 Java 클래스에 해당. 엔티티 클래스의 필드는 데이터베이스 테이블의 Column을 표현

3. Hibernate :
최근에 가장 자주 쓰이는 JPA 구현체로 스프링부트에서 기본 구현체로 사용. 대규모 애플리케이션에 주로 사용

## 엔티티 클래스(Entity)
JPA에서 @Entity 애너테이션을 이용하는 Java 클래스로 표준 Java bean 명명 규칙을 따르고 적절한 getter / setter 메서드 보유. 그리고 private로 설정

애플리케이션이 초기화될 때 클래스 이름으로 데이터베이스 테이블 생성. 다른 이름으로 지정하려면 엔티티 클래스에 @Table 애너테이션을 별개로 달기

-> 
1. field 명이 column명
2. class 명이 table명

H2  데이터베이스 / JPA 이용을 위해 build.gradle 수정
```java
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'  추가
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    runtimeOnly 'com.h2database:h2'                                         추가
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```
Car Entity class
```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String brand, model, color, registrationNumber;

    private int modelYear, price;
}
```
1. @Id : DB에서의 테이블의 Primary Key에 해당하는 field에 달아주는 애너테이션


2. @GeneratedValue : 
- 데이터베이스가 자동으로 ID 생성하게 지정(ID값을 우리가 객체 생성시 일일히 넣지 않음. 다른 키 생성 전약 사용 가능). AUTO JPA 공급자가 특정 데이터베이스에 가장 적합한 전략을 선택한다는 의미로 default값
- DB에서의 column명은 기본적으로 클래스 필드 명명 규칙에 따라 지정. 그래서 다른 컬럼명으로 지정하려면 @Column 애너테이션을 활용해 커스텀

3. @Column : 컬럼 명을 사용자화 / 컬럼의 길이 / 컬럼의 nullable 여부릴 지정 가능

```java
import javax.annotation.processing.Generated;

@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    
    @Column(name="explantion", nullable=false, length=512)
    private String description;
}
```
즉 Car 클래스의 description 필드는 car 테이블의 explanation라는 컬럼명을 갖게되고 VARCHAR(512)로 데이터 길이가 지정되 null 불가라는 의미 

```properties
spring.application.name=cardatabase
spring.datasource.url=jdbc:h2:mem:testdb
spring.jpa.show-sql=true
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
```
이후 chrome에서 `http://localhost:8080/h2-console` 접속

빈출 오류
1. domain 패키지가 test 내에 있으면 실행은 되나 sql문 실행 ㅁ불가
2. application.properties에서 오타 빈출
   - 이 경우 실행은 되지만 콘솔 출력 불가능

## CRUD repository 생성
Spring Data JPA는 CRUD 작업을 위한 CrudRepository 라는 인터페이스가 있고 해당 인터페이스는 엔티티 클래스에 CRUD 기능 제공

domain 패키지에 interface인 CarRepository 생성
```java 
package com.example.cardatabase.domain;

import org.springframework.data.repository.CrudRepository;

public interface CarRepository extends CrudRepository<Car, Long> {
}
```
CarRepository는 JPA의 CrudRepository 인터페이스를 바탕을 확장된 클래스(상속받아서 부모 클래스의 필드/ 메서드 사용 가능. 둘 다 인터페이스니 추상 메서드들 상속)

그리고 `<Car, Long>` 타입의 argument는 Car 엔티티 클래스의 리포지토리이고 id 필드의 타입이 Long임을 명시. 이상의 제네릭으로 Car - CarRepository 관계가 Entity - Repository 관계로 성립

CrudRepository 인터페이스는 추상 메서드들 존재

### CrudRepository의 추상 메서드 소개
1. long count() - 엔티티의 수를 반환
2. Iterable<T> findAll() - 지정한 타입의 모든 항목을 반환                             - Read
3. Optional<T> findById(ID id) - 지정한 ID의 한 항목을 반환(JS에서 getElementById())  - Read
4. void delete(T entity) - 엔티티 삭제                           - Delete
5. void deleteAll() - 리포지토리 내의 모든 엔티티 삭제              - Delete
6. `<S extends T>` save(S entity) - 엔티티를 저장                - Create
7. `List<S>` saveAll(`Iterable<S>` entities) - 여러 엔티티 저장  - Create

method가 한 항목반 반환될 때는 T 대신 `Optional<T>`를 반환. Optional 클래스는 Java 8 SE에서 처음 도입된 타입으로 값을 포함하거나 포함하지 않는 대신 단일 값 컨테이너(특정 id 값이 없는 경우 보통 메서드 결과값이 오류로 발생하기에 막는 용도로 Optional)

값이 있으면 isPresent() 메서드가 true를 반환하고 없으면 false를 반환. 그리고 값이 있을 때만 get()메서드를 통해 값 반환. 해당 Optional을 사용하면 NullPointerException을 방지 가능

이제 H2 인메모리에 예제 데이터를 집어넣기. 인메모리 DB는 실행될때마다 DB를 다시 만들고 종료될 때 삭제해서 h2-console에서 값을 입력해도 껏다 키면 사라지기에 SpringBoot 내에 삽입

CommandLineRunner 인터페이스를 사용 -> 애플리케이션이 완전히 삭제 전에 특정 코드 실행

CarDatabaseApplication에 CommandLineRunner를 구현

```java
package com.example.cardatabase;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication implements CommandLineRunner {
	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
	}
}
```

새로운 Car 객첼들 데이터베이스에 저장화기 위해 CarRepository를 main 클래스에 주입. 생성자 주입 개념을 통해 CarRepository 주입

```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String brand, model, color, registrationNumber;

    private int modelYear, price;
    
    // JPA는 기본 생성자가 필수요구
    public Car() {
    }

    public Car(String brand, String model, String color, String registrationNumber, int modelYear, int price) {
        this.brand = brand;
        this.model = model;
        this.color = color;
        this.registrationNumber = registrationNumber;
        this.modelYear = modelYear;
        this.price = price;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String getRegistrationNumber() {
        return registrationNumber;
    }

    public void setRegistrationNumber(String registrationNumber) {
        this.registrationNumber = registrationNumber;
    }

    public int getModelYear() {
        return modelYear;
    }

    public void setModelYear(int modelYear) {
        this.modelYear = modelYear;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }
}
```

Car entity 클래스에서 기본 생성자를 지우고 getter setter도 삭제 했다면 해당 부분을 lombok의 도입으로 해결

1. intelij상의 plugin에 롬복 쳌
   - ctrl + alt + s -> 플러그인
2. mvn에서 lombok 최신 버전 설치
   - groovy short 확인
3. build.grade의 dependencies에
   implementation 'org.projectlombok:lombok:1.18.42'
```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	runtimeOnly 'com.h2database:h2'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	implementation 'org.projectlombok:lombok:1.18.42'
	annotationProcessor 'org.projectlombok:lombok:1.18.42'
}
```

Spring Data Repository에 쿼리를 정의하는게 가능(=/= SQL). 쿼리는 접두사(prefix : findBy)로 시작해야하고 그 다음 쿼리에 이용할 엔티티 클래스 필드를 정의

main에 
```java
System.out.println(repository.findByBrand('Kia'));
```
라고 작성시 콘솔창에 `[Car(id=1, ...,)]`과 같은 형태로 출력

CarRepository에 색상으로 자동차들을 검색할 수 있게 메서드를 정의하고 main에 White 색을 호출해 콘솔창에 표시

CarRepository에 연도로 자동차들을 검색하게 메서드를 정의하고 main에 2024로 호출해 콘솔창에 표시
```java
package com.example.cardatabase.domain;

import org.springframework.data.repository.CrudRepository;

import java.util.List;

public interface CarRepository extends CrudRepository<Car, Long> {
    // 브랜드로 자동차를 검색
    List<Car> findByBrand(String brand);
    List<Car> findByColor(String color);
    List<Car> findByModelYear(int modelYear);

    // 브랜드와 모델을 합쳐서 자동차 검색
    List<Car> findByBrandAndModel(String brand, String model);

    // 브랜드 또는 색상별로 자동차 검색
    List<Car> findByBrandOrColor(String brand, String color);

    // 브랜드로 자동차를 검색하고 연도롤 정렬
    List<Car> findByBrandOrderByModelYearAsc(String brand);
}
```

`@Query` 애너테이션을 사용하면 직접 SQL문을 작성해 쿼리 메서드를 만들기 가능. 하지만 이름은 고정
```java
@Query("Select c from Car where c.brand =?1")
    List<Car> findByBrand(String brand);
```
확인 결과 @Query가 있으나 없으나 List는 똑같이 작성이 되는데 쓰는 이유는 복잡한 쿼리 작성이나 LIKE와 같은 고급 표현식을 사용할 때 적용

처음 작성한 방식은
```java
System.out.println(repository.findByBrand("Ki"));
```
식으로는 brand에 Ki가 존재하지 않으면 아예 결과값이 없지만 @Query 사용 시 LIKE를 쓸 수 있기에 

```java
package com.example.cardatabase.domain;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;

import java.util.List;

public interface CarRepository extends CrudRepository<Car, Long> {
    // SQL문을 활용한 브랜드로 자동차 검색
    @Query("select c from Car c where c.brand =?1")
    List<Car> findByBrand(String brand);

    // SQL을 활용한 블랜드로 자동차를 검색하는데 부분 검색 저용
    @Query("select c from Car c where c.brand like %?1")
    List<Car> findByBrandEndsWith(String brand);

    @Query("select c from Car c where c.brand like ?1%")
    List<Car> findByBrandStartsWith(String brand);
}
```

Spring Data JPA에서는 CrudRepository로부터 확장된 PaggingAndSortingRepository도 있는데 이 인터페이스는 페이징 및 정렬을 통해 엔티티를 검색하는 메서드 제공. 이 경우 대규모 결과 집합에서 모든 데이터를 반환할 필요 없기에 대규모 데이터 처리하기 적합
```java
package com.example.cardatabase.domain;

import org.springframework.data.repository.PagingAndSortingRepository;

public interface CarRepository extends PagingAndSortingRepository <Car, Long> {
}
```
제공하는 메서드
1. Iterable<T> findAll(Sort sort) - 지정된 옵션으로 정렬된 모든 엔티티를 반환
2. Page<T> findAll(Pagable pagable) - 지정된 페이징 옵션으로 모든 엔티티 반환

결과적으로는 JpaRepository 사용

## 테이블 간의 관계 추가
car 테이블과 일대다(1:N) 관계에 있는 owner라는 새 테이블 생성. 일대 다 관계는 소유자가 한 명이 여러대의 자동차를 가질 수 있지만 한 자동차의 소유자는 1명

