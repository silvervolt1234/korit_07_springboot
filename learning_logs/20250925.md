# 자격 증명을 저장하는 새 클래스
- Record 데이터만 보관하는 새 클래스가 필요할 때 많은 상용구를 피하는 방식으로
```java
package com.example.cardatabase.domain;

public record AccountCredentials(String username, String password) {}
```
- 처럼 작성하면 username / password에 대한 Getter / Setter 필요 없음

# Java Record
- Record는 데이터 운반체(Data Carrier) 역할을 하는 클래스를 간결하게 생성하기 위해 14에서 도입되었고 16에서 정식기능화. 주로 DTO(Data Transfer Object)나 POJO(Plain Old Jav Object)와 같은 불변 데이터 객체를 만들 때 발생하는 반복적인 상용구 코드(boilerplate code) 작성을 줄이는걸 목표로 개발

## Record 특징
1. 간결성
   - field만을 정의시 컴파일러가 필요한 메서드 자동 생성
   - 이상의 경우 username과 password에 대한 getter / setter를 자동 생성
2. 불변성
   - 모든 field는 private final로 선언 -> private니 getter/setter로 경유해 값을 넣기
3. 자동생성
   - 이하의 멤버들이 자동 생성
     1. AllArgsConstructor - () 내에 정의된 모든 field를 사용하는 생성자 자동 생성
     2. 접근자 메서드(Accessor Methods) : 전통적으로 특정 field에 접근하기 위한 접두사 `get`을 사용하지 않고 field명 사용. person.getName()과 같이 사용이 아닌 person.name()
4. 제약사항
   - 다른 클래스를 상속 불가능
   - 다른 인스턴스 field를 선언할 수 없고 레코드 header에 정의된 field들 외의 field는 static이여함
```java
public record Person(String name, int age) {
    // getter / setter는 알아서 만들어져 lombok 등 불필요
    // 객체 생성 시 유효성 검사를 위해 생성자 커스텀 가능
    public Person {
        if (age < 0) {
            throw new IllegalAccessException("불가능한 나이 입력입니다.");
        }
    }
}

public class PersonMain {
    public static void main(String[] args) {
        // Record를 통한 객체 생성 및 사용 방법 예시들을 작성
        Person person1 = new Person("김일", 21);  // AllArgsConstructor가 기본 생성이니 이걸로만 객체 생성 가능
        String name = person1.name();
        System.out.println(name + " 학생은 " + person1.age() +"살입니다.");
        System.out.println(person1.toString());     // 원래 toString()은 직접 호출 없이 객체명만으로 뽑을 수 있었지만 여기선 이런 형태로 사용. Person[name=김일, age=21]
    }
}
```
# Java Optional
`java.util.Optional<T>` 클래스는 Java 8에서 도입되고 값이 있을수도 없을수도 있는 컨테이너 객체. 주요 목적은 null 값을 직접 처리하지 못하게 해 프로그래머의 실수를 줄이고 흔히 발생하는 `NullPointerExcption` 예외를 방지하는 것

## Optional 특징
1. NPE 방지
   - 메서드의 return 값이 null이 될 가능성이 있을 때(findByUsername(username)의 결과값이 null일 수 있는 것처럼) Optional을 도입시 호출자는 명시적으로 값이 없을 때의 상황을 처리하게 강제
2. 함수형 스타일
   - map(), filter(), ifPresent() 등의 메서드를 제공하고 함수형 프로그래밍 스타일로 코드 작성
3. 의도 노출
   - Optional을 도입하는 것만으로도 특정 메서드의 return 값이 null이 될 수 있음을 다른 개발자들이 알 수 있음

### Optional 객체 생성 및 사용 방법
1. Optional.of(T value)
   - null이 아닌 값으로 Optional을 생성. 이 메서드의 호출로 value에 null을 넣을시 NullPointerException이 발생
2. Optional.ofNullable(T value)
   - value가 null일 수도 있는 값으로 Optional 생성. null이면 Optional.empty()를 return
3. Optional.empty()
   - 값이 없는 Optional 객체 return

### 데이터 처리 메서드(NPE 방지 및 대체)
1. isPresent()
- 값이 존재하면 true 반환
2. get()
- 값을 반환. 값이 없으면 NoSuchElementException을 발생 시키니 isPresent()로 확인 후 사용하거나 다른 메서드 사용

```java
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    Optional<AppUser> user = userRepository.findByUsername(username);

    UserBuilder builder = null;
    if (user.isPresent()) { // 이하의 실행문이 실행되면 user에 AppUser가 있다는 의미  // 이 부분에서 Optional 1번 메서드 사용
        AppUser currentUser = user.get();                                          // 여기서도 2번 메서드 사용
        builder = User.withUsername(username);
        builder.password(currentUser.getPassword());
        builder.roles(currentUser.getRole());
    } else {
        throw new UsernameNotFoundException("User not found.");
    }
    
    return builder.build();
}
```
3. orElse(T other)
   - 값이 존재하면 그 값을 반환하고 값이 없으면 `other`로 전달된 기본값을 return
4. orElseGet(Supplier<? extends T> other)
   - 값이 존재하면 그 값을 반환하고 값이 없으면 `other`(람다식)의 결과를 반환(orElse와 달리 값이 없는 경우만 람다식 호출)
5. ifPresent(Consumer <? super T> action)
   - 값이 존재하는 경우만 `action`(람다식)을 실행

## Optional 사용 예시

```java
import java.util.Optional;

public class Example1 {
    public static void main(String[] args) {
        Optional<String> maybeName = Optional.ofNullable(findByUsername(username)); // 값이 null 일수도 있음
        
        // 1. 값이 있을 경우만 작업을 수행하는 .ifPresent() - 람다식 적용
        maybeName.ifPresent(name -> System.out.println("사용자 이름 : " + name));
        
        // 2. 값이 없을 때 기본 값 제공
        String name = maybeName.orElse("Guest");  // 값이 없으면 Guest를 return
        System.out.println("사용자 이름 : " + name);     // 사용자 이름 : Guest가 결과값
        
        // 3. 값이 없을 떄의 예외 발생
        String requiredName = maybeName.orElseThrow();  // 값이 없으면 NoSuchElementException 발생
    }
}
```

# 로그인을 위한 AccountCredentials를 Record로 생성
1. 로그인을 위한 controller 클래스 생성. `/login` 엔드포인트를 POST 메서드로 호출하고 사용자 이름과 암호를 요청 본문과 전송해 로그인(Spring Security의 default를 사용하지 않는다는 의미)
   - web 패키지 내에 LoginController 클래스 생성
   - 로그인 성공 시 JWT를 생성하는데 이용할 JwtService 인스턴스를 컨트롤러 클래스에 삽입
```java
package com.example.cardatabase;

import com.example.cardatabase.domain.AccountCredentials;
import com.example.cardatabase.service.JwtService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LoginController {
    // field 선언 -> final 키워드
    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;
    
    // 그래서 필수적으로 AllArgsConstructor로 생성하고
    public LoginController(JwtService jwtService, AuthenticationManager authenticationManager) {
        this.jwtService = jwtService;
        this.authenticationManager = authenticationManager;
    }
    
    // POST 요청을 위한 method 작성하고 field로 받아온 부분을 사용해 method 호출을 LoginController의 getToken() 메서드 내에서 수행
    @PostMapping("/login")
    public ResponseEntity<?> getToken(@RequestBody AccountCredentials credentials) {
        // 여기에 토큰 생성하고 응답의 Authorization 헤더로 전송하는 로직 작성
    }
}
```

1. ResponseEntity 클래스
- 정의
  - ResponseEntity<T>는 Spring에서 HTTP 응답 전체를 나차내느 클래스로 Controller 클래스에서 사용. 웹 애플리케이션 컨트롤러 메서드에서 이 클래스를 return할 시 개발자가 응답의 데이터(Body), HTTP 상태 코드(Status Code), 그리고 HTTP heaer를 명시적 제어 가능
  - RESTful API 설계에서 서버의 상태를 클라이언트에 명확히 전달에 필수적
  
- 주요 특징 및 구성 요소
  1. Body(본문)
    - 클라이언트에게 실제로 전송되는 데이터 `<>`로 저장
    - `User` 객체, `List<Product>` 등(JSON 형태로 변환되서 전송(postman에서 JSON 기준))
  2. Status Code(상태 코드)
    - 요청 처리 결과를 나타내는 3자리 숫자
    - HttpStatus.OK - 200
    - HttpStatus.CREATED - 201
    - HttpStatus.NOT_FOUND - 404
  3. Headers(헤더)
    - 응답에 대한 추가 메타 데이터
    - HttpHeaders.CONTENT_TYPE
    - HttpHeaders.AUTHORIZATION
    - HttpHeaders.LOCATION

## ResponseEntity<T> 예시

```java
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

import java.net.URI;

// 1. 성공 응답 (200 OK)
@GetMapping("/users/{id}")
public ResponseEntity<User> getUser(@PathVariable Long id) {
    User user = userService.findById(id);

    // 상태 코드 200 OK와 User 객체를 응답 본문에 담아서 반환
    return new ResponseEntity<>(user, HttpStatus.OK);
}

// 2. 생성 성공 응답 (201 Created)
// .created() 빌더를 활용해 Location 헤더를 자동 추가 가능
@PostMapping("/products")
public ResponseEntity<Void> createProduct(@RequestBody Product newProduct) {
    Product saveProduct = productService.save(newProduct);

    // 상태 코드 201 Created와 함께 Location 헤더를 반환(Body는 없음-POST 요청 시 Body를 썻는데 여기서는 GET 요청시 Body 작성 없이도 결과값에 JSON이 있었으니 패스 가능)
    return ResponseEntity.created(URI.create("/products" + saveProduct.getId())).build();
}

// 3. 실패 응답 (404 Not Found)
@GetMapping("/items/{id}")
public ResponseEntity<String> getItem(@PathVariable Long id) {
    if (itemService.findItem(id) == null) {
        // 상태 코드 404 Not Found와 에러 메세지를 ResponseEntity의 body에 담아서 return
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("해당 item을 찾을 수 없습니다.");
    }
    // 여기 부분은 아이템을 찾았을 때 로직 장성
    // 기타 로직 이후 마지막
    return ResponseEntity.status(HttpStatus.OK);
}
```
# POST 요청시에 필요한 @RequestBody 애너테이션
- 정의
HTTP 요청 메서드(POST, PUT, PATCH 등)의 요청 본문(body)에 담긴 데이터를 읽어와 Spring Controller 메서드의 매개변수로 연결(binging)할 때 사용. 클라이언트가 서버로 데이터 존송 시 주로 사용

- 특징 및 작동 원리
1. 자동 역질렬화 : `@RequestBody`의 핵심 기능으로 요청 본문에 포함된 JSON, XML등의 데이터를 메서드 매개변수로 지정된 Java
2. 메세지 컨버터(Message Converter) : Spring의 `HttpMessageConverter`가 담당하는 부분으로 예시로 JSON 데이터가 들어오게 되면 Jackson라이브러리르 사용하는 컨버터가 이를 JAVA 객체로 변환
3. 데이터 바인딩 : 요청 body의 field 이름과 대상 Java 객체의 field이름이 일치시 자동 값 주입

## @RequestBody 사용 예시

```java
import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@Getter
@Setter
public class Product {
    private String name;
    private int price;
}

// 컨트롤러
@PostMapping("/products")
// 클라이언트 요청 본문의 JSON 데이터를 자동으로 Product 객체인 product로 변환
public ResponseEntity<String> addProduct(@RequestBody Product) {
    // product 객체는 이미 JSON의 "name"과 "price"키를 담고 있는 상황

    if (product.getPrice() <= 0) {
        return ResponseEntity.badRequest().body("가격은 양수여야만 합니다.");  // 400 BAD_REQUEST
    }

    productService.save(product);
    return ResponseEntity.status(HttpStatus.CREATED).body("상품이 성공적으로 등록됬습니다");
}
```
- 참고 사항 : `@RequestBody`는 요청 본문(body)이 없는 GET 요청에는 사용할 수 없고 `POST`, `PUT`와 같은 데이터 전송이 필요한 요청에 사용

LoginController의 GetToken
```java
@PostMapping("/login")
public ResponseEntity<?> getToken(@RequestBody AccountCredentials credentials) {
    // 여기에 토큰 생성하고 응답의 Authorization 헤더로 전송하는 로직 작성
    UsernamePasswordAuthenticationToken creds =
            new UsernamePasswordAuthenticationToken(credentials.username(), credentials.password());
    // credentials.username() 은 Record로 만들어서 getUsername이 아님

    Authentication auth = authenticationManager.authenticate(creds);

    // 토큰 생성 - jwts가 지역 변수 취급
    String jwts = jwtService.getToken(auth.getName());

    // 생성된 토큰으로 응답을 빌드
    return ResponseEntity
            .ok()
            .header(HttpHeaders.AUTHORIZATION,"Bearer " + jwts)
            .header(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, "Authorization")
            .build();
}
```
이상까지 작성했을 때 LoginController의 field로 AuthorizationManger를 사용해서 SecurityConfig에 설정 추가 필요

```java
// SecurityConfig.java
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
```
이상을 기준으로 스픵 시큐리티 Config 관련을 손대야 하기에 Spring security의 SecurityFilterChain bean은 어떤 경로(엔드포인트)가 보호되고 어떤 경로가 보호되지 않는지 정의

.filterChain()메 서드를 추가하는데 기본적인 정의는 /login 엔드포인트에 대한 POST 요청은 인증이 없어도 허용되게 작성

또한 Spring Security가 세션을 생성하지 않기에 사이트 간 요청 위조(csrf)를 비활성화하게 정의. JWT는 상태 비저장형으로 설계되 세션 관련 취약성 감소. HTTP 보안 구성에서는 Lambda Expression 사용

# @PathVariable 애너테이션

- 정의 및 목적 : 해당 애너테이션은 Spring Web에서 URL의 경로 변수(Path Variable)에 있는 값을 추출해 Controller의 메서드의 매개변수로 바인딩하는데 사용. 이는 특정 리소스를 식별하거나 조회 할 때 RESTful API 디자인 구현에 핵심적인 역할


- 특징 및 작동 원리
1. URL 경로 매핑 : URL 경로의 특정 부분을 변수처럼 `{id}`와 같이 표시하고 그 변수에 할당된 실제 값을 메서드 매개변수로 가져옴
2. RESTful 식별자 : 주로 개별 리소스(특정 사용자 ID / 특정 상품 번호 등)를 식별하기 이해 사용하며 URL(Uniform Resource Identifier)의 의미를 명호가히 함
3. 자동 타입 변환 : 경로에서 추출된 문자열은 메서드 매개변수의 타입(`Long, Integer, String` 등)에 맞게 자동 변환

## 예시

```java
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

public class User {
    private Long id;
    private String name;
    //...
}

@RestController
@RequestMapping("/api/users")
public class UserController {
    // 1. 단일 경로 변수 사용 예시
    // URL : /api/users/123
    @GetMapping("/{userId}")
    // {userId} 경로의 값 123을 Long 자료형의 userId 변수에 바인딩(대입)
    public ResponseEntity<User> getUserById(@PathVariable("userId") Long id) {
        // PathVariable로 받은 userId를 이용해 특정 사용자를 조회
        User user = userService.findById(id);
        
        if (user == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(user); // 200 OK와 user 데이터를 응답
    }
    
    // 2. 여러 PathVariable의 사용 예시
    @GetMapping("/{userId}/orders/{orderId}")
    public ResponseEntity<Order> getUserOrder(
        @PathVariable Long userId, @PathVariable Long orderId
    ) { // 변수 이름이 같으면 ("userId") / ("orderId")가 생략 가능
        Order order = orderService.findByUserIdAndOrderId(userId, orderId);
        return ResponseEntity.ok(order);
    }
}
```

# 다른 요청 보호하기
Login을 하지 않고도 들어갈 수 있는 엔드 포인트인 POST / login 부분을 처리. 그러면 이제 나머지 수신 요청에 대한 인증 처리를 다룰 필요가 있는데 인증 프로세서에서는 요청이 Controller에 전달되기 전 클라이언트에 응답이 전송되기 전 일부 작업을 수행 가능한 filter 이용

1. 필터 클래스를 이용, 다른 모든 수신 요청을 인증 처리. com.example.cardatabase에 AuthenticationFilter 클래스를 생성. 해당 클래스는 Spring Security의 OncePerRequestFilter 인터페이스를 확장해 인증을 구현할 수 있는 doFilterInternal 메서드 제공. request에서 토큰 확인을 위해 필터 크래스에 JwtService 인스턴스 주입. SecurityContextHolder는 Spring Security가 인증된 사용자의 세부 정보를 저장하는 부분에 해당. 이하의 코드에서 검증
```java
package com.example.cardatabase;

import com.example.cardatabase.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@RequiredArgsConstructor
public class AuthenticationFilter extends OncePerRequestFilter {
    private final JwtService jwtService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // 토큰 가져오기
        String jws = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (jws != null) {
            // 토큰 검증 및 사용자 가져오기
            String user = jwtService.getAuthUser(request);
            // 인증
            Authentication authentication = new UsernamePasswordAuthenticationToken(user,null, Collections.emptyList());

            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        filterChain.doFilter(request, response);
    }
}
```
getAuthUser()의 return 타입이 직접 정의했기에 확인해야하는데 String user 부분과 같이 확인. 그리고 SecurityConfig에 filter 관련 클래스 추가 요구됨

```java
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .sessionManagement(sessionManagement ->
                        sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeHttpRequests ->
                        authorizeHttpRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }
```
이전에는 `authorizeHttpRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated());` 서 종료됬었지만 이상의 코드는 기본적으로 `/login` 엔드포인트에 POST 요청을 허용한다는 것이기에 나머지 부분에 JWT가 존재함다면 요청 처리를 위해 `.addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class);`를 추가

이상까지 작성하면 로그인 이후 과정의 워크플로우를 테스트 할 수 있게 되고 애플리케이션 실행 후 POST / LOGIN을 하면 Authorization 헤더에 JWT 존재 여부를 체크 가능하며 body내에 유효한 사용자를 추가하고 postman을 통해 자동으로 지정하지 않으면 Headers에 Content-Type을 application/json으로 설정

로그인 성공시 JWT Authorization 헤더를 통해 전송해 다른 RESTful 서비스의 엔드 포인트 호출이 가능. 로그인 응답에 나온 토큰을 복사해(Response의 Header에서 Authorization의 `Bearer`를 제외한) 응답에서 Authorrization 헤더를 추가 후 붙여넣기

# 예외 처리하기
현재 상황에서 postman에서 /login POST 요청을 할 때 CommandLineRunner에 입력한 더미 데이터와 다른 방식으로 로그인을 시도한다면(username 오타 혹은 password 오타) 403 에러 메세지가 출력.즉 추가 설명도 없고 그냥 금지만 안내를 해서 개발자 / 유저 입장에선 오류의 원인을 알 수 없음. 그래서 username / password 오타시 401 Unauthorized 에러 메세지를 띄우는 등 에러별 커스텀 메세지 출력

Authentication 관련 예외를 처리하기 위해서는 AuthenticationEntryPoint 인터페이스를 사용 가능

1. AuthEntryPoint 클래스 생성 후 AuthenticationEntryPoint 인터페이스를 implement 후 예외가 발생하면 응답을 401로 설정, 응답 본문에 예외 메세지 출력
```java
package com.example.cardatabase;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.PrintWriter;

@Component
public class AuthEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType(MediaType.APPLICATION_CBOR_VALUE);
        PrintWriter writer = response.getWriter();
        writer.println(("Error : wrong id or password") + authException.getMessage());
    }
}
```
Authentication이 로그인시 요구되는 username / password를 입력해 현재 기준 app_user라는 table 내에 해당 username / password가 존재하는지 확인하는 과정

SecurityConfig 관련 수정 필요

다 수정하고 나면 POST / login에서 username / password 중 하나가 dummy data와 다른 겨웅 403 -> 401로 바뀌며 직접 설정한 message가 응답 받은 JSON 내용에 삽입